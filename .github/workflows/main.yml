name: Task

on:
  workflow_dispatch:
  repository_dispatch:
    types: [restart-vds]

jobs:
  build:
    runs-on: ubuntu-latest
    # Общий таймаут job — 50 минут
    timeout-minutes: 50

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Restore Data from Backup (artifact)
        id: restore
        run: |
          set -euo pipefail
          # Попробуем загрузить последний артефакт (если он существует) через GitHub API
          # Если артефакт недоступен — продолжаем с чистой рабочей директорией
          echo "No automatic restore implemented — ensure relevant files are in the repo or provide manual restore steps."
          # При необходимости можно добавить скачивание артефакта через actions/download-artifact,
          # но workflow run-to-run артефакты недоступны напрямую без конкретной реализации.

      - name: Setup and Run tmate (ephemeral)
        id: tmate_session
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y tmate jq
          # Запускаем tmate в фоне
          tmate -S /tmp/tmate.sock new-session -d
          tmate -S /tmp/tmate.sock wait tmate-ready
          TMATE_SSH=$(tmate -S /tmp/tmate.sock display -p '#{tmate_ssh}')
          TMATE_WEB=$(tmate -S /tmp/tmate.sock display -p '#{tmate_web}')
          # Маскируем в логах
          echo "::add-mask::${TMATE_SSH}"
          echo "::add-mask::${TMATE_WEB}"
          echo "TMATE_SSH_URL=${TMATE_SSH}" >> $GITHUB_OUTPUT
          echo "TMATE_WEB_URL=${TMATE_WEB}" >> $GITHUB_OUTPUT

      - name: Save SSH Link to File (local only)
        run: |
          set -euo pipefail
          echo "${{ steps.tmate_session.outputs.TMATE_SSH_URL }}" > ssh_link.txt
          echo "${{ steps.tmate_session.outputs.TMATE_WEB_URL }}" >> ssh_link.txt
          chmod 600 ssh_link.txt

      - name: Notify via Telegram (send SSH link) and short window
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          TMATE_SSH: ${{ steps.tmate_session.outputs.TMATE_SSH_URL }}
          TMATE_WEB: ${{ steps.tmate_session.outputs.TMATE_WEB_URL }}
        run: |
          set -euo pipefail
          if [ -z "${TMATE_SSH}" ] && [ -z "${TMATE_WEB}" ]; then
            echo "No tmate link available, skipping Telegram notify."
          else
            TEXT="TMATE SSH: ${TMATE_SSH}%0AWeb: ${TMATE_WEB}%0A(Ссылка замаскирована в логах.)"
            TELE_URL="https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage"
            curl -s -X POST "${TELE_URL}" -d chat_id="${TELEGRAM_CHAT_ID}" -d parse_mode="HTML" -d text="${TEXT}" | jq -e '.ok' >/dev/null
          fi
          # Окно для подключения — 10 минут (600s)
          echo "Ephemeral tmate window: 10 minutes"
          sleep 600
          # После окна убиваем сервер tmate (чтобы не держать сессию)
          tmate -S /tmp/tmate.sock kill-server || true

      - name: Keep remaining time (short wait before backup)
        run: |
          set -euo pipefail
          # Учитываем, что job лимит 50 минут. Выделяем время на бэкап/загрузку/триггер.
          # После 10 минут работы tmate остаётся примерно ~40 минут. Делаем небольшой буфер: ждем 5 минут.
          sleep 300

      - name: Create Backup
        run: |
          set -euo pipefail
          echo "Creating data backup..."
          # Исключаем .git и артефакты, а также временный файл с ссылкой
          zip -r vds_backup.zip . -x ".git/*" "vds_backup.zip" "ssh_link.txt"

      - name: Upload Backup Artifact
        uses: actions/upload-artifact@v4
        with:
          name: vds-backup
          path: vds_backup.zip

      - name: Trigger Next VDS Run with backoff
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Простая логика retry с экспоненциальным backoff (3 попытки)
          REPO="${{ github.repository }}"
          PAYLOAD='{"event_type":"restart-vds"}'
          ATTEMPT=0
          MAX=3
          DELAY=5
          SUCCESS=0
          while [ $ATTEMPT -lt $MAX ]; do
            ATTEMPT=$((ATTEMPT+1))
            echo "Trigger attempt #${ATTEMPT}"
            HTTP=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: token ${GITHUB_TOKEN}" \
              "https://api.github.com/repos/${REPO}/dispatches" \
              -d "${PAYLOAD}")
            if [ "$HTTP" = "204" ] || [ "$HTTP" = "200" ]; then
              echo "Dispatch accepted (HTTP $HTTP)"
              SUCCESS=1
              break
            else
              echo "Dispatch failed (HTTP $HTTP), sleeping ${DELAY}s"
              sleep $DELAY
              DELAY=$((DELAY*2))
            fi
          done
          if [ $SUCCESS -ne 1 ]; then
            echo "Failed to trigger next run after ${MAX} attempts" >&2
            exit 0
          fi
